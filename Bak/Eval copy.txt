{-# LANGUAGE LambdaCase #-}
module Eval where

import           Control.Applicative (liftA2)
import           Control.Monad.Reader

import qualified Data.Map as M
import qualified Data.Set as S

import           Env
import           Expr

data Redc = RUdf
          | RCst Int
          | RNil
          | RFun Motif Expr EvalEnv
          | RCpl Redc Redc
          | RLst Redc Redc
          | RThk Expr

instance Show Redc where
    show = \case
        RUdf      -> "_|_"
        RCst k    -> show k
        RFun {}   -> "<fun>"
        RCpl x y  -> "(" ++ show x ++ ", " ++ show y ++ ")"
        RLst x y  -> show x ++ " :: " ++ show y
        RThk _    -> "<thunk>"
        RNil      -> "[]"

data EvalError = ValueError
               | UnboundVar String
               | RedUndef
               deriving (Eq, Show, Ord)

type EvalEnv = (Namespace String Redc)
type Reducer = ReaderT EvalEnv (Either EvalError)

-- Bare minimum environment to run LazyML programs
bare :: EvalEnv
bare = using "undefined" RUdf
     $ empty

evalOp :: EAop -> (Int -> Int -> Int)
evalOp Add = (+)
evalOp Min = (-)
evalOp Mul = (*)
evalOp Div = div
evalOp Mod = mod
evalOp And = \x y -> if (x /= 0) && (y /= 0) then y else 0 
evalOp Or  = \x y -> if x /= 0 then x else y
evalOp Le  = \x y -> if x < y then 1 else 0
evalOp Leq = \x y -> if x <= y then 1 else 0
evalOp Ge  = \x y -> if x > y then 1 else 0
evalOp Geq = \x y -> if x >= y then 1 else 0
evalOp Eq  = \x y -> if x == y then 1 else 0
evalOp Df  = \x y -> if x /= y then 1 else 0

err :: EvalError -> Reducer a
err = lift . Left

usefulEnv :: Expr -> Reducer EvalEnv
usefulEnv e = do
    env <- ask
    let vars = varsOfExpr e
    return $ M.restrictKeys env vars

find :: String -> Reducer Redc
find x = do
    env <- ask
    case retrieve x env of
        Nothing -> err $ UnboundVar x
        Just r  -> return r

unify :: Motif -> Redc -> Reducer (EvalEnv -> EvalEnv)
unify m r = case (m, r) of
    (MWdc, _)     -> return id
    (MVar x, r)   -> return $ using x r
    (MCpl x y, RCpl r1 r2) -> liftA2 (.) (unify x r1) (unify y r2)
    (MLst x y, RLst r1 r2) -> liftA2 (.) (unify x r1) (unify y r2)
    (_, RThk e) -> whnf r >>= unify m
    _ -> err ValueError

whnf :: Redc -> Reducer Redc
whnf = \case
    RThk (ECst k) -> return $ RCst k
    RThk (EFun x e) -> do
        env <- usefulEnv e
        return $ RFun x e env 
    RThk (EVar x) -> find x >>= whnf
    RThk (ECpl e1 e2) -> return $ RCpl (RThk e1) (RThk e2)
    RThk (ELst e1 e2) -> return $ RLst (RThk e1) (RThk e2)
    RThk ENil       -> return RNil
    RThk (EAex op e1 e2) -> do
        r1 <- eval e1
        r2 <- eval e2
        case (r1, r2) of
            (RCst k1, RCst k2) -> return $ RCst $ evalOp op k1 k2
            _ -> err ValueError
    RThk (EApp e1 e2) -> do
        r1 <- eval e1
        case r1 of
            RFun m e env -> do
                ts <- unify m (RThk e2)
                local (const $ ts env) $ whnf (RThk e)
            _ -> err ValueError
    RThk (ELet m e1 e2) -> do
        ts <- unify m (RThk e1)
        local ts $ whnf (RThk e2)
    RThk (EIte eb e1 e2) -> do
        rb <- eval eb
        case rb of
            RCst t ->
                if t == 0
                    then whnf $ RThk e2
                    else whnf $ RThk e1
            _ -> err ValueError
    RUdf -> err RedUndef 
    r    -> return r

eval :: Expr -> Reducer Redc
eval = \case
    ECst k   -> return $ RCst k
    EFun m e -> do
        env <- usefulEnv e
        return $ RFun m e env
    EVar x   -> do
        r <- find x
        case r of
            RThk e -> eval e
            _      -> return r
    EAex op e1 e2 -> do
        r1 <- eval e1
        r2 <- eval e2
        case (r1, r2) of
            (RCst k1, RCst k2) -> return $ RCst $ evalOp op k1 k2
            _ -> err ValueError
    ECpl e1 e2 -> liftA2 RCpl (eval e1) (eval e2)
    ELst e1 e2 -> liftA2 RLst (eval e1) (eval e2)
    ENil       -> return RNil
    EApp e1 e2 -> do
        r1 <- eval e1
        case r1 of
            RFun m e env -> do
                ts <- unify m (RThk e2)
                local (const $ ts env) $ eval e
            _ -> err ValueError
    ELet m e1 e2 -> do
        ts <- unify m (RThk e1)
        local ts $ eval e2
    EIte eb e1 e2 -> do
        rb <- eval eb
        case rb of
            RCst t ->
                if t == 0
                    then eval e2
                    else eval e1
            _ -> err ValueError

instance Prettify Motif where
    prettify MWdc       = "_"
    prettify (MVar x)   = x
    prettify (MCpl x y) = "(" ++ prettify x ++ ", " ++ prettify y ++ ")"
    prettify (MLst x y) = "(" ++ prettify x ++ "::" ++ prettify y ++ ")"
    prettify  MNil      = "[]"

instance Prettify Expr where
    prettify = aux 0
        where aux pad = \case
                ECst k        -> show k
                EVar x        -> x
                EApp u v      -> recapp pad u ++ " " ++ pars pad v 
                EFun m e      -> "fun " ++ prettify m ++ " => " ++ aux pad e
                ELet m e1 e2  -> "let " ++ prettify m ++ " = " ++ aux pad e1 ++ " " ++ reclet pad e2
                EAex op e1 e2 -> pars pad e1 ++ " " ++ prettify op ++ " " ++ pars pad e2
                ECpl e1 e2    -> "(" ++ pars pad e1 ++ ", " ++ pars pad e2 ++ ")"
                ELst e1 e2    -> pars pad e1 ++ "::" ++ pars pad e2
                ENil          -> "[]"
                EIte eb e1 e2 -> nl pad ++ "if " ++ aux pad eb ++ nl (pad + 2) ++ "then " ++ aux pad e1 ++ nl (pad + 2) ++ "else " ++  aux pad e2
                EMch e cs     -> nl pad ++ "match " ++ aux pad e ++ " with" ++ concatMap (\(m,e) -> 
                                    nl (pad + 2) ++ prettify m ++ " -> " ++ aux (pad + 2) e) cs
                EThk nb       -> "<thunk#" ++ show nb ++ ">"
              nl pad = '\n' : (replicate pad ' ')
              pars pad e@EFun {}    = "(" ++ aux pad e ++ ")"
              pars pad e@EApp {}    = "(" ++ aux pad e ++ ")"
              pars pad e@ELet {}    = "(" ++ aux pad e ++ ")"
              pars pad e@EAex {}    = "(" ++ aux pad e ++ ")"
              pars pad e@ELst {}    = "(" ++ aux pad e ++ ")"
              pars pad e            = aux pad e
              recapp pad (EApp u v) = recapp pad u ++ " " ++ pars pad v
              recapp pad e          = pars pad e
              reclet pad (ELet m e1 e2) = nl pad ++ "and " ++ prettify m ++ " = " ++ aux pad e1 ++ " " ++ reclet pad e2
              reclet pad e              = "in" ++ nl (pad + 2) ++ aux (pad + 2) e