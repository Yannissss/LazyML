{-# LANGUAGE LambdaCase #-}
module Eval where

import           Control.Applicative (liftA2)
import           Control.Monad (void)
import           Control.Monad.State

import Debug.Trace

import qualified Data.Map as M
import qualified Data.Set as S
import qualified Data.Vector as V

import           Env
import           Expr

data NF = NFCst Int
        | NFNil
        | NFFun Motif Expr
        | NFCpl NF NF
        | NFLst NF NF
        deriving (Eq, Show, Ord)

instance Prettify NF where
    prettify = \case
        NFCst k -> show k
        NFNil -> "[]"
        NFFun _ _ -> "<fun>"
        NFCpl x y -> "(" ++ prettify x ++ ", " ++ prettify y ++ ")"
        NFLst x y -> "[" ++ prettify x ++ reclst y ++ "]"
        where reclst NFNil = ""
              reclst (NFLst x y) = ";" ++ prettify x ++ reclst y
              reclst nf = prettify nf

data Thunk = TNF NF
           | TCpl Thunk Thunk
           | TLst Thunk Thunk
           | TRaw [(String, Int)] Expr
           | TRef Int
           deriving (Eq, Show, Ord)

data RError = ValueError
            | UnboundVar String
            | NoMatch
            | PanicError
            deriving (Eq, Show, Ord)

type REnv = Namespace String Int
type RState = (Namespace String Int, V.Vector Thunk)
type Red = StateT RState (Either RError)

bare :: (Namespace String Int, V.Vector Thunk)
bare = (empty, V.empty)

evalOp :: EAop -> (Int -> Int -> Int)
evalOp Add = (+)
evalOp Min = (-)
evalOp Mul = (*)
evalOp Div = div
evalOp Mod = mod
evalOp And = \x y -> if (x /= 0) && (y /= 0) then y else 0 
evalOp Or  = \x y -> if x /= 0 then x else y
evalOp Le  = \x y -> if x < y then 1 else 0
evalOp Leq = \x y -> if x <= y then 1 else 0
evalOp Ge  = \x y -> if x > y then 1 else 0
evalOp Geq = \x y -> if x >= y then 1 else 0
evalOp Eq  = \x y -> if x == y then 1 else 0
evalOp Df  = \x y -> if x /= y then 1 else 0


substMotif :: Motif -> Expr -> Expr -> Red Expr
substMotif m u t = case (m, u) of
    (MWdc, _) -> return t
    (MVar x, _) -> return $ substExpr x u t
    (MCpl x y, ECpl e1 e2) -> substMotif y e2 t >>= substMotif x e1
    (MLst x y, ELst e1 e2) -> substMotif y e2 t >>= substMotif x e1
    _ -> err ValueError

err :: RError -> Red a
err = lift . Left

getEnv :: Red REnv
getEnv = do
    (env, _) <- get
    return env

putEnv :: REnv -> Red ()
putEnv env = do
    (_, mtable) <- get
    put (env, mtable)

push :: String -> Int -> Red ()
push x nb = do
    (env, mtable) <- get
    put (using x nb env, mtable)

usefulEnv :: Expr -> Red REnv
usefulEnv e = do
    (env, _) <- get
    let vars = varsOfExpr e
    return $ M.restrictKeys env vars

find :: String -> Red Int
find x = do
    env <- getEnv
    case retrieve x env of
        Nothing -> err $ UnboundVar x
        Just r  -> return r

repr :: Int -> Red Thunk
repr nb = do
    nb' <- aux nb
    (_, mtable) <- get
    V.indexM mtable nb'
    where aux nb = do
            (env, mtable) <- get
            thk <- V.indexM mtable nb
            case thk of
                TRef nb' -> do
                    nb'' <- aux nb'
                    put (env, mtable V.// [(nb, TRef nb'')])
                    return nb''
                _ -> return nb :: Red Int

new :: Thunk -> Red Int
new thk = do
    (env, mtable) <- get
    let nb = V.length mtable
    put (env, V.snoc mtable thk)
    return nb

save :: Expr -> Red Int
save e = do
    env <- usefulEnv e
    let env' = map (\(x,y) -> (x, head y)) $ M.toList env
    new $ TRaw env' e

update :: Int -> Thunk -> Red ()
update nb thk = do
    (env, mtable) <- get
    put (env, mtable V.// [(nb, thk)])

unify :: Int -> Motif -> Expr -> Red Expr
unify nb m e = case m of
        MWdc     -> return e
        MVar x   -> do
            push x nb
            return $ substExpr x (EThk nb) e
        MCpl x y -> do
            reduceWHNF nb
            thk <- repr nb
            case thk of
                TCpl thk1 thk2 -> do
                    nb1 <- new thk1
                    nb2 <- new thk2
                    unify nb1 x e >>= unify nb2 y
                _ -> err ValueError
        MNil ->  do
            v <- reduceNF nb
            case v of
                NFNil -> return e
                _ -> err ValueError
        MLst x y -> do
            reduceWHNF nb
            thk <- repr nb
            case thk of
                TLst thk1 thk2 -> do
                    nb1 <- new thk1
                    nb2 <- new thk2
                    unify nb1 x e >>= unify nb2 y
                _ -> err ValueError

unifyMatch :: Int -> [(Motif, Expr)] -> Red Expr
unifyMatch nb = \case
    [] -> err NoMatch
    ((m,e):cs) -> case m of
        MWdc     -> return e
        MVar x   -> do
            push x nb
            return $ substExpr x (EThk nb) e
        MCpl x y -> do
            reduceWHNF nb
            thk <- repr nb
            case thk of
                TCpl thk1 thk2 -> do
                    nb1 <- new thk1
                    nb2 <- new thk2
                    unify nb1 x e >>= unify nb2 y
                _ -> unifyMatch nb cs
        MNil -> do    
            reduceWHNF nb
            thk <- repr nb
            case thk of
                TNF NFNil -> return e
                _ -> unifyMatch nb cs
        MLst x y -> do
            reduceWHNF nb
            thk <- repr nb
            case thk of
                TLst thk1 thk2 -> do
                    nb1 <- new thk1
                    nb2 <- new thk2
                    unify nb1 x e >>= unify nb2 y
                _ -> unifyMatch nb cs

reduceWHNF :: Int -> Red ()
reduceWHNF nb = do
    thk <- repr nb
    case thk of
        TRef _' -> err PanicError 
        TRaw xs e ->  
            let aux (x, k) = substExpr x (EThk k)
            in
            case foldr aux e xs of
            ECst k -> update nb $ TNF $ NFCst k
            EFun x e -> update nb $ TNF $ NFFun x e
            ENil -> update nb $ TNF $ NFNil
            EVar x -> do
                nb' <- find x
                update nb (TRef nb')
            EThk nb' -> do
                update nb $ TRef nb'
                reduceWHNF nb'
            ECpl x y -> do
                nb1 <- save x
                nb2 <- save y
                update nb $ TCpl (TRef nb1) (TRef nb2)
            ELst x y -> do
                nb1 <- save x
                nb2 <- save y
                update nb $ TLst (TRef nb1) (TRef nb2)
            EAex op e1 e2 -> do
                lhs <- eval e1
                rhs <- eval e2
                case (lhs, rhs) of
                    (NFCst k1, NFCst k2) -> update nb $ TNF $ NFCst $ evalOp op k1 k2
                    _ -> err ValueError
            EApp e1 e2 -> do
                lhs <- eval e1
                case lhs of
                    NFFun m e -> do
                        nb <- save e2
                        nb' <- save e
                        e' <- unify nb m e 
                        update nb' $ TRaw [] e'
                        reduceWHNF nb'
                    _ -> err ValueError
            ELet m e1 e2 -> do
                nb <- save e1
                nb' <- save e2
                e2' <- unify nb m e2
                update nb $ TRaw [] e2' 
                reduceWHNF nb'
            EIte eb e1 e2 -> do
                rb <- eval eb
                case rb of
                    NFCst t ->
                        if t /= 0
                            then do
                                nb' <- save e1
                                reduceWHNF nb'
                                update nb $ TRef nb'
                            else do
                                nb' <- save e2
                                reduceWHNF nb'
                                update nb $ TRef nb'
                    _ -> err ValueError
            EMch e cs -> do
                nb' <- save e
                e' <- unifyMatch nb' cs
                nb'' <- save e'
                update nb $ TRef nb''
                reduceWHNF nb''
        _ -> return ()

reduceNF :: Int -> Red NF
reduceNF nb = do
    thk <- repr nb
    case thk of
        TRef _' -> err PanicError 
        TRaw xs e ->  
            let aux (x, k) = substExpr x (EThk k)
            in
            case foldr aux e xs of
            ECst k -> do
                let nf = NFCst k
                update nb (TNF nf)
                return nf
            EFun x e -> do
                let nf = NFFun x e
                update nb (TNF nf)
                return nf
            ENil -> do
                let nf = NFNil
                update nb (TNF nf)
                return nf
            EVar x -> do
                nb' <- find x
                reduceNF nb'
            EThk nb' -> do
                nf <- reduceNF nb'
                update nb $ TRef nb'
                return nf
            ECpl x y -> do
                nf1 <- eval x
                nf2 <- eval y
                let nf = NFCpl nf1 nf2
                update nb (TNF nf)
                return nf
            ELst x y -> do
                nf1 <- eval x
                nf2 <- eval y
                let nf = NFLst nf1 nf2
                update nb (TNF nf)
                return nf
            EAex op e1 e2 -> do
                lhs <- eval e1
                rhs <- eval e2
                case (lhs, rhs) of
                    (NFCst k1, NFCst k2) -> do
                        let nf = NFCst $ evalOp op k1 k2
                        update nb (TNF nf)
                        return nf
                    _ -> err ValueError
            EApp e1 e2 -> do
                lhs <- eval e1
                case lhs of
                    NFFun m e -> do
                        nb2 <- save e2
                        e' <- unify nb2 m e
                        update nb $ TRaw [] e'
                        reduceNF nb
                    _ -> err ValueError
            ELet m e1 e2 -> do
                nb1 <- save e1
                nb2 <- save e2
                e2' <- unify nb1 m e2
                update nb $ TRaw [] e2'
                reduceNF nb
            EIte eb e1 e2 -> do
                rb <- eval eb
                case rb of
                    NFCst t ->
                        if t /= 0
                            then eval e1
                            else eval e2
                    _ -> err ValueError
            EMch e cs -> do
                nb' <- save e
                e' <- unifyMatch nb' cs
                nb'' <- save e'
                update nb $ TRef nb''
                reduceNF nb''
        TCpl thk1 thk2 -> do
            nb1 <- new thk1
            nb2 <- new thk2
            nf1 <- reduceNF nb1
            nf2 <- reduceNF nb2
            return $ NFCpl nf1 nf2
        TLst thk1 thk2 -> do
            nb1 <- new thk1
            nb2 <- new thk2
            nf1 <- reduceNF nb1
            nf2 <- reduceNF nb2
            return $ NFLst nf1 nf2
        TNF nf -> return nf

eval :: Expr -> Red NF
eval e = do
    env <- getEnv
    v <- aux e
    putEnv env
    return v
    where aux = \case
            ECst k -> return $ NFCst k
            EVar x -> do
                nb <- find x
                reduceNF nb
            EThk nb -> reduceNF nb
            EFun x e -> return $ NFFun x e
            ELet m e1 e2 -> do
                nb <- save e1
                e2' <- unify nb m e2
                eval e2'
            EAex op e1 e2 -> do
                lhs <- eval e1
                rhs <- eval e2
                case (lhs, rhs) of
                    (NFCst k1, NFCst k2) -> return $ NFCst $ evalOp op k1 k2
                    _ -> err ValueError
            EApp e1 e2 -> do
                nf1 <- eval e1
                case nf1 of 
                    NFFun x e -> do
                        nb <- save e2
                        e' <- unify nb x e
                        eval e'
                    _ -> err ValueError
            ECpl e1 e2 -> do
                nf1 <- eval e1
                nf2 <- eval e2
                return $ NFCpl nf1 nf2
            ELst e1 e2 -> do
                nf1 <- eval e1
                nf2 <- eval e2
                return $ NFLst nf1 nf2
            ENil -> return NFNil
            EIte eb e1 e2 -> do
                nf <- eval eb
                case nf of
                    NFCst t -> 
                        if t /= 0
                            then eval e1
                            else eval e2
                    _ -> err ValueError
            EMch e cs -> do
                nb' <- save e
                e' <- unifyMatch nb' cs
                eval e'